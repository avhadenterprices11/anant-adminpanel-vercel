import { useState, useEffect } from 'react';
import type { TierFormData, Tier } from '../types/tier.types';
import { notifyError } from '@/utils';

/**
 * Tier form hook options
 */
interface UseTierFormOptions {
    mode?: 'create' | 'edit';
    initialData?: Partial<TierFormData> | Tier;
    selectedParent?: Tier;
}

/**
 * Default form data for new tiers
 */
const getDefaultFormData = (): TierFormData => ({
    name: '',
    code: '',
    level: 1,
    parentId: null,
    status: 'active',
    description: '',
});

/**
 * Standard tier form hook following products pattern
 * 
 * @example
 * // Creating new tier
 * const { formData, updateField, handlers } = useTier Form({ mode: 'create' });
 * 
 * @example
 * // Creating sub-tier
 * const { formData, updateField, handlers } = useTierForm({ 
 *   mode: 'create',
 *   selectedParent: parentTier
 * });
 * 
 * @example
 * // Editing existing tier
 * const { formData, updateField, handlers } = useTierForm({ 
 *   mode: 'edit',
 *   initialData: tierData
 * });
 */
export function useTierForm(options: UseTierFormOptions = {}) {
    const { mode = 'create', initialData, selectedParent } = options;

    // 1. Form data state
    const [formData, setFormData] = useState<TierFormData>(() => {
        const defaults = getDefaultFormData();

        // If creating a sub-tier, pre-fill level and parentId
        if (mode === 'create' && selectedParent) {
            return {
                ...defaults,
                level: (selectedParent.level + 1) as 2 | 3 | 4,
                parentId: selectedParent.id,
            };
        }

        // If editing or has initial data, merge
        if (initialData) {
            return {
                ...defaults,
                ...initialData,
            };
        }

        return defaults;
    });

    // Store initial snapshot for change detection
    const [initialFormSnapshot, setInitialFormSnapshot] = useState<TierFormData | null>(null);

    // Sync formData when initialData changes (e.g. after async fetch)
    useEffect(() => {
        if (initialData && Object.keys(initialData).length > 0) {
            const mergedData = {
                ...getDefaultFormData(),
                ...initialData,
            };
            setFormData(mergedData);
            setInitialFormSnapshot(mergedData);
        }
    }, [initialData]);

    // Handle mode and selectedParent changes
    useEffect(() => {
        if (mode === 'create' && selectedParent) {
            // Creating a sub-tier
            const subTierData = {
                ...getDefaultFormData(),
                level: (selectedParent.level + 1) as 2 | 3 | 4,
                parentId: selectedParent.id,
            };
            setFormData(subTierData);
            setInitialFormSnapshot(subTierData);
        } else if (mode === 'create' && !selectedParent) {
            // Creating a root tier
            const rootTierData = getDefaultFormData();
            setFormData(rootTierData);
            setInitialFormSnapshot(rootTierData);
        }
        // For edit mode, the initialData useEffect handles it
    }, [mode, selectedParent]);

    // 2. UI state
    const [ui, setUi] = useState({
        isLoading: false,
        isSaving: false,
    });

    // 3. Error state for validation
    const [errors, setErrors] = useState<Partial<Record<keyof TierFormData, string>>>({});

    // === CORE OPERATIONS ===

    /**
     * Generate code/slug from name
     */
    const generateCodeFromName = (name: string): string => {
        return name
            .toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/-+/g, '-')
            .trim();
    };

    /**
     * Generic field update handler
     */
    const updateField = <K extends keyof TierFormData>(
        field: K,
        value: TierFormData[K]
    ) => {
        setFormData(prev => {
            const updated = { ...prev, [field]: value };

            // Auto-generate code from name
            // Only update code if it's currently empty OR if it matches the slug of the previous name
            // (meaning it hasn't been manually diverged by the user)
            if (field === 'name') {
                const currentNameSlug = generateCodeFromName(prev.name);
                const isAutoGenerated = !prev.code || prev.code === currentNameSlug;

                if (isAutoGenerated) {
                    updated.code = generateCodeFromName(value as string);
                }
            }

            // Clear parentId if level is 1
            if (field === 'level' && value === 1) {
                updated.parentId = null;
            }

            return updated;
        });

        // Clear error for this field
        if (errors[field]) {
            setErrors(prev => ({ ...prev, [field]: undefined }));
        }
    };



    /**
     * Handle name change with auto-code generation
     */
    const handleNameChange = (value: string) => {
        setFormData(prev => ({
            ...prev,
            name: value,
            code: prev.code || generateCodeFromName(value),
        }));
    };

    /**
     * Handle input change for generic text/number inputs
     */
    const handleInputChange = (
        field: keyof TierFormData,
        value: string | number | boolean | null
    ) => {
        updateField(field, value as TierFormData[typeof field]);
    };

    /**
     * Validate form data
     */
    /**
     * Validate form data
     */
    const validate = (): boolean => {
        // Name validation
        if (!formData.name.trim()) {
            notifyError('Tier name is required');
            const element = document.getElementById('tier-name');
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                element.focus();
            }
            return false;
        }

        // Code validation
        if (formData.code && !/^[a-z0-9-]+$/.test(formData.code)) {
            notifyError('Code must contain only lowercase letters, numbers, and hyphens');
            const element = document.getElementById('tier-code');
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                element.focus();
            }
            return false;
        }

        // Parent validation
        if (formData.level > 1 && !formData.parentId) {
            notifyError('Parent tier is required for sub-tiers');
            const element = document.getElementById('parent-tier-section');
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            return false;
        }

        setErrors({});
        return true;
    };

    /**
     * Check if form has changes
     */
    const hasChanges = (): boolean => {
        if (!initialFormSnapshot) return false;

        const current = {
            name: formData.name,
            code: formData.code,
            level: formData.level,
            parentId: formData.parentId,
            status: formData.status,
            description: formData.description,
        };

        const initial = {
            name: initialFormSnapshot.name,
            code: initialFormSnapshot.code,
            level: initialFormSnapshot.level,
            parentId: initialFormSnapshot.parentId,
            status: initialFormSnapshot.status,
            description: initialFormSnapshot.description,
        };

        return JSON.stringify(current) !== JSON.stringify(initial);
    };

    /**
     * Reset form to initial state
     */
    const reset = () => {
        if (initialFormSnapshot) {
            setFormData(initialFormSnapshot);
        } else {
            setFormData(getDefaultFormData());
        }
        setErrors({});
    };

    /**
     * Reset form for creating a new sub-tier under the selected parent
     */
    const resetForSubTier = (parent: Tier) => {
        setFormData({
            ...getDefaultFormData(),
            level: (parent.level + 1) as 2 | 3 | 4,
            parentId: parent.id,
        });
        setErrors({});
    };

    // === HANDLERS ===

    const handlers = {
        handleNameChange,
        handleInputChange,
        validate,
        reset,
        resetForSubTier,
    };

    return {
        // Data
        formData,
        errors,
        ui,
        mode,

        // Computed
        isValid: Object.keys(errors).length === 0,
        hasChanges: hasChanges(),

        // Operations
        updateField,
        setUi,

        // Handlers
        ...handlers,
    };
}
